## [1] Thread 동기화와 동시성

### Program
• 컴퓨터가 실행 가능한 프로그래밍 언어로 작성된 인스트럭션(명령)의 셋 또는 시퀀스를 의미한다.

• 일반적으로 소프트웨어에 속하는 컴포넌트

일반적으로 프로그램이 메모리에 로딩되어 실행되는 인스턴스 -> 이 프로세스는 하나 이상의 스레드에 의해 실행된다.

• 하나의 프로그램이 여러 프로세스가 될 수도 있다.

- 대부분의 프로세스는 다음을 포함하고 있다

    - 프로그램 내에 코드
    - 할당 받은 시스템 리소스
    - 물리적 또는 논리적 권한
    - 초기 자료구조

• OS에 따라 인스트럭션을 동시에 실행하기 위한 멀티 스레드 환경으로 구성될 수 있다.

• 멀티 태스킹 : 여러 프로세스가 프로세서, 시스템 리소스 등을 공유하는 것

즉 일정 기간동안 여러 프로세스를 동시에 실행

• 프로세스는 일반적으로 리소스를 공유하지 않게 설계되어 있다. 

( 하지만 IPC(Inter-Process Communication) 프로세스 간 통신을 통해 가능하긴 함 

즉, `프로세스들간의 데이터를 공유하고 메시지를 주고 받을 때 문제`가 생기고, "이것을 어떻게 해결할 것인가?"에 관한 것이 IPC라고 할 수 있다. )

    ※ IPC의 종류 1) PIPE 2) Named PIPE 3) Message Queue 4) Shared Memory 5) Memory Map 6) socket


**1. shared memory(공유 메모리)** : 공유 메모리를 이용해서 데이터를 주고 받는 방법.

특징 : IPC를 위해 공유 메모리 영역을 구축하고, 공유 영역을 통해 자원이나 데이터를 주고받는다.

장점 : 커널 의존성이 낮기 때문에 속도가 빠르다. 유저 레벨에서 IPC가 가능하기 때문에, 통신이 자유롭다.

단점 : 자원과 데이터를 공유하기 때문에 동기화 이슈가 발생한다. 유요한 데이터를 잘 전달하기 위해서는 동기화 기술 필요
![image](https://github.com/lielocks/java_til/assets/107406265/e5f5415a-21a6-4769-ae14-bc53dc7ac141)


**2. message passing(메시지 전달)** : 메시지를 주고 받는 방법

특징 : IPC를 위해 커널을 통해 메시지를 전달하는 방식으로 자원이나 데이터를 주고받는다. 구현이 간단하고 적은 양의 데이터 전달에 적합

장점 : 별도로 다른 것을 구축할 필요 없이 커널을 이용하기 때문에 구현이 비교적 쉽다. 

단점 : 커널을 이용하기 때문에, 시스템 콜(System call)이 필요하며 이로 인해 오버헤드가 발생한다. 매번 커널을 통하여 정보/메세지를 전달하기 위해 두 번 복사(매번 시스템 호출 사용)

종류 : 파이프, 시그널, 메시지 큐, 소켓 등

커널이 *send*와 *recive*를 제공한다. 

이 때, 단점 두 가지는

커널을 제공하기 때문에 커널을 거치기 떄문에 데이터 복사가 일어나서 느려지는 것과 send라는 것을 사용하기 때문에 메모리를 무한정 줄 수 없고 `channel(채널)의 크기 만큼만` 줄 수 있다.

![image](https://github.com/lielocks/java_til/assets/107406265/0fc96b82-4163-45ee-a96e-50488d5f256f)

**3. Semaphore(세마포어)** :

프로세스 간 메시지를 전송하거나, 공유메모리를 통해 특정 데이터를 공유하게 되는 경우 문제가 발생할 수 있다


프로세스간 메시지 전송을 하거나, 혹은 Shared Memory를 통해서 특정 데이타를 공유하게 될 경우 발생하는 문제가

공유된 자원에 여러개의 프로세스가 동시에 접근하면 안되며, 단지 한번에 하나의 프로세스만 접근 가능하도록 만들어줘야 할 것이며, 이 때 사용되는 것이 Semaphore이다.

 

즉, 공유된 자원에 여러 개의 프로세스가 동시에 접근하면서 문제가 발생하는 것으로써 공유된 자원 속 하나의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한해 두어야 하는데, 

이를 위하여 고안된 것이 바로 Semaphore 세마포어다. **상호배제 원리를 보장**하는 알고리즘이다.

    ※ 공유 리소스에 접근할 수 있는 최대 허용치 만큼 동시 사용자 접근을 할 수 있게 하는 기술
       동기화 대상이 여러 개일 경우 사용

![image](https://github.com/lielocks/java_til/assets/107406265/e71f2925-cd94-4f93-803a-610c05c2eab0)

![image](https://github.com/lielocks/java_til/assets/107406265/6bb64e16-010e-43f7-96a0-e19b4f62f324)

![image](https://github.com/lielocks/java_til/assets/107406265/fd3560b4-d69f-4165-8dda-33c55e30c5bc)

### Thread

• OS의 일부인 스케줄러에 의해 독립적으로 관리되는 프로그래밍 인스트럭션의 최소 시퀀스

context switching으로 resource가 덜 든다. 하지만 오버헤드가 있어서 resource 사용량 업 -> process에 비해 덜 드는 것이다. 또한 os thread와 mapping이 안된다.

즉 프로세스를 실행시키기 위한 최소 시퀀스이자 일종의 프로세스 실행 단위라고 할 수 있음

• 일반적으로 스레드는 프로세스의 구성 요소이며 OS 마다 스레드의 구현이 다름

• 멀티 스레딩 기능을 통해 스레드 간 메모리를 포함한 시스템 리소스를 공유할 수 있음

실행 코드, 변수에 동적으로 할당된 값, 전역 변수 등을 언제든 공유할 수 있음

![image](https://github.com/lielocks/java_til/assets/107406265/c069df03-7e2b-412c-854a-48fc61ca364a)

### Process 사용과 비교했을 때 Thread 사용 장단점
- 장점
  - 프로세스 그룹보다 메모리 등 리소스 공유가 원활함
  - 실제 멀티코어인 경우 멀티 스레드는 실제로 병렬 처리가 가능
  - 스레드 간 컨텍스트 스위칭이 프로세스 컨텍스트 스위칭보다 훨씬 빠름

- 단점
  - 스레드 그룹은 리소스 공유로 인해 하나의 스레드가 오작동을 일으키면 다른 스레드도 영향을 받음
    프로세스 그룹은 OS 레벨에서 격리되어 있어 스레드 그룹보다 안전함
  - 서로 다른 시스템에서 실행될 수 없음


## reference source

https://junghyungil.tistory.com/146
